#summary Design and implementation overview.
#labels Featured

= News =

With this release the tiled2 branch is live. The included tiletmxloader v3 brings optimizations and bug fixes. The gummworld2 library brings many optimizations and a few bug fixes, and quite a bit of internal redesign as well as some API changes. Some dead modules and toolkit functions have been removed.

Some API changes were necessary to bring in the new features.

= Introduction =

This is Gummworld2. It's designed as a light [http://www.pygame.org pygame] framework for a [http://pyweek.org/e/multifac/ scrolling game], where the map is larger than the display. It emphasizes simplicity, freedom, and performance.

Gummworld2 is foremost about optimal scrolling. It provides just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use the engine for the game framework, [http://www.mapeditor.org/ Tiled] for maps, and [http://www.pygame.org/project-pymunk-780-2576.html pymunk] for physics. Examples and a toolkit are included to demonstrate the ease of incorporating these. If you prefer to use other libraries and utilities, it is quite easy to use Gummworld2 simply for scrolling maps and leverage your own tools.

In fact, even maps and scrolling are optional. If you wish to use the Engine or core classes simply for the program framework, Gummworld2 [http://pyggy.pyweek.org/e/gummX1/ lends itself well].

Besides ease and speed of scrolling maps, Gummworld2 strives to maintain these ideals:

  One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 fosters this notion by requiring only a few core classes, and a clean and simple update-and-draw run loop.

  One should be free to choose one's own audiovisual presentation, game intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want. You are not forced to learn "The Gummworld Way", and wade through bloated features.

  One should not have to worry about juggling game speed and frame rates, and eking enough horsepower for a smooth gaming experience. Gummworld2's clock maintains steady game time and variable frame rate without the headaches. The management classes and toolkit do what they do with efficiency leaving more computer resources for game content.

Given the name Gummworld2, one may wonder about the original [http://www.pygame.org/project-Gummworld-1107-.html Gummworld]. While it was a great learning experience and a lot of fun, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= API Overview =

Gummworld2 is currently developed with Windows 7, Python 2.6, pygame 1.9.1, pymunk 1.0.0, and Tiled Map Editor 0.6.1 (the Qt version). Most of the testing is on the development platform. Light testing for demo performance and operation has been done with Windows XP SP 2 and Ubuntu 10. Almost assuredly Gummworld2 will not work with pygame 1.8.1 and earlier, since various classes may not have provided the copy() method (most notably Rect) and other new features.

The library performs basic scrolling of tiles by syncing a camera with a target object that moves about the large map space. Change the target object's position and the camera follows.

These are the core classes.

  State: A storage container for run-time objects, settings, and values. Because it's easy to access globally, this minimizes the need to pass around core objects in arguments. States can also be saved and restored by name, if desired. The mechanism is straightforward, thus easy to use and extend.

  Engine: A superclass providing the framework for initialization, run loop, update and draw methods, and pygame event handlers. If you decide to write your own framework, look in here to see how the core objects are created. Don't be afraid, no voodoo in here.

  Screen and View: Basic display and subsurface wrappers.

  Camera: Follows a target object around the map. Calculates 2D range of visible tiles. Constructs map-layer lists of visible tiles. Converts 2D coordinates between world and screen space. Provides interpolated scrolling, taking advantage of faster frame rates and time-sensitive positioning to smooth the scrolling experience.

  Map: Serves map tiles in layers. Also serves labels and grid lines as design aids.

  World`*`: Containers for objects that define the game model. Choices are NoWorld, World, WorldQuadTree, and WorldPymunk which provide some "canned" options for implementing a world. You are free to use these, build your own, or ignore it entirely.

  GameClock: Keeps constant game time. No-fuss variable frame rate. Calculates interpolated fraction of a game tick, which can be used for prediction, sub-pixel motion, and precision timing.

BucketSprite and BucketGroup: Not core classes, but worthy of mention. They are pygame-like classes that manage sprites in buckets for optimized updating and rendering. BucketGroup also has a tweaked draw() method needed to render sprites whose rects are expressed in world coordinates--versus pygame's which expect sprite rects to be expressed in screen coordinates. These are for game makers who prefer to use the sprite for both view and model.

The data module provides resource loaders for various data in the data subdirectories, a la skellington. It should be very easy to figure out and customize as needed.

The geometry module provides numerous collision routines to augment pygame's, geometric calculations, and some shapes.

There are a few utilities to simplify laborious tasks and ease experimentation with concepts: a HUD, map grid, tile labels, popup menu, map generators, Tiled map loader, tile renders, tile collapsing, pygame utilities module, and PGU's gui package. The examples and world_editor.py rely upon those modules. However, they are not required by the library, with the exception that toolkit.py and pygame_utils.py. Of special interest, the toolkit module provides a number of "quickie" functions for both practical use and demonstrations of how to manipulate library objects, most notably Map and Camera.

The nicer examples use Tiled maps. While this is one of the easiest ways to make and import tile maps, it is not required. Any map source can be used as long as its data can be converted to the Map class's meager requirements. See the toolkit module for a few functions that load maps, the bunny game for an ASCII map, and the Map class documentation.

Note that although pymunk and Tiled are supported, they are not required. There is no need to consider them if you prefer not to use them. However, at this time the world editor only imports Tiled maps. Tiled maps are not critical to the operation of the editor or Gummworld2, but at present they certainly make designing layout a lot easier in the editor.

Lastly, a general caution. The instance variables representing 2D coordinates are typically implemented as `Vec2d`. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when overriding in subclasses or choosing to directly access the underlying private `_attributes`.

==Status Summary==

Initial efforts focused on the map, its visual presentation, and interface. Recently attention has turned to the world (model) editor. The API has not had any code-breaking changes since version 0.0.7.

A mini game was finished in 0.0.2 as a proof-of-concept, and kept functional as the library evolved. The game and all but one example do not use an external physics library; I would describe them as pygame-only. A few examples use Tiled maps.

The editor is not a map editor. Tiled already does that well. Gummworld2's editor supplements Tiled's static maps by visually overlaying tagged geometry for physics--e.g. rects and circles for pygame; circles and polygons for pymunk or others--and placement of interactive game content, e.g. baddies, doors, traps. The geometry would typically be invisible in the game, and used for game events like:

  * Did my space ship hit the cavern wall.
  * Did my truck venture into this sand pit.
  * Did the mouse click on this unit of soldiers.
  * Is this baddy in striking range of the avatar.
  * Is this defense tower visible in the camera view.

Performance is extremely good on my Intel Core i3 laptop. Not so great on my older AMD Athlon X2 desktop, but still much better than the original Gummworld; demos scream at Diablo-like resolution (800x600), leaving plenty of capacity for dynamic content.

An aged Intel single-core 1.8 GHz with cheap on-board video and DDR-333 pulled off 40-60 FPS on examples. However, the scrolling experience was sluggish and really jerky since the platform was not fast enough to drive smooth interpolation and still work in garbage collection. The quadtree examples did not run acceptably at all, except with low sprite counts. Scrolling on old platforms such as this may still be possible at smaller resolutions.

===Features===

Anything marked DONE in the following list is not necessarily frozen. It is just considered adequately usable for recent SVN revisions. These will certainly evolve as needed.

Library:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * World:
    * NoWorld is the default, for game makers that do not want a canned model (DONE)
    * World is a dumb model with a list for entities (DONE)
    * WorldQuadTree is an advanced model that provides optimal collision checking in large maps with many elements (DONE)
    * WorldPymunk is a model that leverages pymunk; needs more shape classes and pymunk-ish things (incomplete)
  * Menu (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * Geometry for more collision detection choices without external library requirements (DONE)
  * Toolkit: hud and tile generators; map loader; world entity loader; render routines; map optimizers (DONE)

Editor:
  * Editing primitives
    * Line (still thinking; it's not compatible with QuadTree)
    * Rect (DONE)
    * Circle (DONE)
    * Polygons (DONE)
    * Select (DONE)
    * Multi-select
    * Move (DONE)
    * Resize (DONE)
    * Delete, cut, copy, paste (DONE)
    * Undo/Redo
  * Map decorating and tiling (for in-editor visual aid only)
    * Tileset loading (DONE)
    * Palette picking (DONE)
    * Screen picking (DONE)
    * Stamping (DONE)
    * Erasing (DONE)

==Working Notes==

===Library===

===pymunk===

pymunk is barely more than a concept thus far. It is fundamentally proven in examples/08_pymunk_motion.py. Shape classes and a map importer will eventually come.

===World Editor===

Game makers can load a map in the editor, draw shapes on it to define game objects, then save a "physics map". Games can load the graphics and physics maps, and rely on pymunk or other implementations for run-time physics. For Python purists, Gummworld2 provides a QuadTree implementation that is compatible with editor files and can leverage geometric shapes for collision detection.

[http://www.mapeditor.org/ Tiled Map Editor] and [http://www.pygame.org/project-map+loader+for+%27tiled%27-1158-2951.html pytmxloader] make a great team. It is a no-brainer to use them, unless you've got a pile of reusable content from other sources.

Placing static obstacles and boundaries on a map is admittedly nice. However, the world editor can also be used to place "spawned" game objects, i.e. objects that are not in static map layers. For example, groups of orcs, gates, siege weapons, random rubble. The world editor can load tilesets to aid visualizing world content design. It's very useful to be able to insert a physical "device" into the world map, size its geometry accurately, and provide a handle or descriptive data for a few reasons:

  # Shapes are needed for dimensions; and potentially other physics-related purposes in the case of pymunk.
  # Shapes do not necessarily require a visual component.
  # Shapes offer geometry options. One can choose irregular shapes, or shapes that snug the edges of visuals smaller than an entire tile.
  # Obviously, if objects in the physics dimension are interacting those interactions need to correlate with the presentation layer.
  # World loaders could detect "Ah, here is a Mark IV Gizmo. I'll load the graphics and game intelligence for it". Or run-time game logic can load presentation content on the fly when the physics are activated by game progression.