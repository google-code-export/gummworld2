#summary Miscellaneous project notes.

= Introduction =

This is Gummworld2. It's designed as a light pygame framework for a scrolling game, where the map is larger than the display. It emphasizes simplicity, openness, and performance.

One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 solves this with a clean and simple update-and-draw run loop.

One should also be free to choose one's own audiovisual presentation, intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want; you are not forced to learn "The Gummworld Way", and wade through bloated features. Gummworld2 does this by providing just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use Tiled for maps and pymunk for physics, as it is quite easy to substitute your own.

One should not have to worry about juggling game speed and frame rates. Gummworld2's clock maintains steady game time and variable frame rate without the headaches.

One may wonder about the original Gummworld. While it was a great learning experience, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= Details =

The map editor performs basic scrolling of tiles by syncing a camera with a target object that moves about the map. Change the target object's position and the camera follows.

There are a few utilities--a HUD, tile grid lines, tile labels, popup menu, toolkit (map generators, tile renders), pygame utilities module--to ease experimentation with concepts, but they are entirely optional. One can use Gummworld2 and easily ignore them.

The physics scale is intended to be based on pixels, however all attempts will be made to support sub-pixel math with floating point numbers. Sub-pixel math is compatible with the underlying physics engine, pymunk (chipmunk), and allows fractional speeds, mass, etc. The display code must round and convert physics values to integers where appropriate.

Also, beware that many underlying coordinate "points" are implemented as {{{Vec2d}}}. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when subclassing or choosing to directly access the underlying {{{obj._attributes}}}.

==Initial focus==

Getting organized.

Developing a map editor, which seconds as a practical test of the library and the requirements driver for library features.

Anything marked DONE in the to-do list is not necessarily frozen. It is just considered adequately usable for the purpose it is most recently needed. They will surely evolve as needed.

Features:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * Procedural object makers, e.g. random groups of baddies
  * Menus (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * pymunk editing primitives
    * Line
    * Circle
    * Poly
    * Select
    * Multi-select
    * Move
    * Resize
    * Delete
    * Undo/Redo
  * ~~Map decorating and tiling
    * ~~Tileset loading
    * ~~Palette picking
    * ~~Screen picking
    * ~~Paint
    * ~~Erase
    * ~~Undo/redo
    * ~~Region selection
    * ~~Fill

==Working Notes==

===Map Editor===

I am liking Tiled Map Editor and pytmxloader. It is looking like map_editor.py will simply load the tile map, and (initially) just let one add pymunk objects.

Since the Map class is already source agnostic, it may be easy enough to support multiple map editor formats just by adding another toolkit.load_`*` function.

The (Tiled) map layers feature can be used to classify terrain objects, for example "trees go on layer 5". Game makers (i.e. me) may want to do special things with these, like let mobile objects pass under or behind them and temporarily lower the image alpha so the mobile object is not entirely obscured. (Note that this aspect weakens the case for map decorating and tiling in map_editor.py.)