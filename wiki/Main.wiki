#summary Miscellaneous project notes.

= Introduction =

This is Gummworld2. It's designed as a light pygame framework for a scrolling game, where the map is larger than the display. It emphasizes simplicity, openness, and performance.

One should not have to struggle with making a game concept fit into a restrictive paradigm and juggling game speed with frame rates. Gummworld2 helps solve these issues with a clean and simple update-and-draw run loop, and a clock that maintains steady game time and variable frame rate.

One should also be free to choose one's own audiovisual presentation, intelligence, and GUIs. The benefits should be obvious: use whatever you want; you don't have to learn "The Gummworld Way".

One may wonder where is the original Gummworld. While it was a great learning experience, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= Details =

The map editor performs basic scrolling of tiles, with numbered labels, grid, HUD, and a popup menu.

The physics scale is intended to be based on pixels, however all attempts will be made to support sub-pixel math with floating point numbers. Sub-pixel math is compatible with the underlying physics engine, pymunk (chipmunk), and allows fractional speeds, mass, etc. The display code must round and convert physics values to integers where appropriate.

Also, beware that many underlying coordinate "points" are implemented as {{{Vec2d}}}. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when subclassing or choosing to directly access the underlying {{{obj._attributes}}}.

==Initial focus==

Getting organized.

Developing a map editor, which seconds as a practical test of the library and the requirements driver for library features.

Anything marked DONE in the to-do list is not necessarily frozen. It is just considered adequately usable for the purpose it is most recently needed. They will surely evolve as needed.

Features:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * Procedural object makers, e.g. random groups of baddies
  * Menus (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * pymunk editing primitives
    * Line
    * Circle
    * Poly
    * Select
    * Multi-select
    * Move
    * Resize
    * Delete
    * Undo/Redo
  * ~~Map decorating and tiling
    * ~~Tileset loading
    * ~~Palette picking
    * ~~Screen picking
    * ~~Paint
    * ~~Erase
    * ~~Undo/redo
    * ~~Region selection
    * ~~Fill

==Working Notes==

===Map Editor===

I am liking Tiled Map Editor and pytmxloader. It is looking like map_editor.py will simply load the tile map, and (initially) just let one add pymunk objects.

Since the Map class is already source agnostic, it may be easy enough to support multiple map editor formats just by adding another toolkit.load_`*` function.

The (Tiled) map layers feature can be used to classify terrain objects, for example "trees go on layer 5". Game makers (i.e. me) may want to do special things with these, like let mobile objects pass under or behind them and temporarily lower the image alpha so the mobile object is not entirely obscured. (Note that this aspect weakens the case for map decorating and tiling in map_editor.py.)