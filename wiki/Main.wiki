#summary Design and implementation progress.
#labels Featured

= Introduction =

This is Gummworld2. It's designed as a light pygame framework for a scrolling game, where the map is larger than the display. It emphasizes simplicity, freedom, and performance.

One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 solves this with a clean and simple update-and-draw run loop.

One should also be free to choose one's own audiovisual presentation, game intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want; you are not forced to learn "The Gummworld Way", and wade through bloated features. Gummworld2 provides just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use the engine for the game framework, Tiled for maps, and pymunk for physics. It is quite easy to substitute your own.

One should not have to worry about juggling game speed and frame rates. Gummworld2's clock maintains steady game time and variable frame rate without the headaches.

One may wonder about the original Gummworld. While it was a great learning experience and a lot of fun, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= Details =

The library performs basic scrolling of tiles by syncing a camera with a target object that moves about the map. Change the target object's position and the camera follows.

These are the key classes.

  State: A storage container for run-time objects, settings, and values. Because it's easy to access globally, this minimizes the need to pass around key objects in arguments. States can also be saved and restored by name, if desired. The mechanism is straightforward, thus easy to use and extend.

  Engine: A superclass providing the framework for initialization, run loop, update and draw methods, and pygame event handlers. If you decide to write your own engine, look in here to see how the key objects are created. Don't be afraid, no voodoo in here. Note that if you want to use pymunk via the Engine, you need to turn it on with use_pymunk=True.

  Screen: Just yer basic display interface.

  Camera: Follows a target object around the map. Calculates 2D range of visible tiles. Constructs map layer lists of visible tiles. Converts 2D coordinates between world and screen space. Supports warping and interpolated scrolling.

  Map: Serves map tiles in layers. Also serves labels and grid lines.

  World: The underlying physics, based on pymunk. The Engine class uses this to maintain physical bodies for motion and collision. If you do not decide to use pymunk you can ignore this object. If you do not have pymunk installed, the World class will automatically live without it.

  GameClock: Keeps constant game time. Supports variable frame rate. Calculates interpolated fraction of a game tick, which can be used for prediction and sub-pixel motion.

The data module provides resource loaders for various data in the data/ subdirectories, a la skellington. It should be very easy to figure out and customize as needed.

There are a few utilities--a HUD, tile grid lines, tile labels, popup menu, toolkit (map generators, tile renders), pygame utilities module--to ease experimentation with concepts, but they are not required (except by the examples and map_editor.py). One can use Gummworld2 and easily ignore them. The toolkit module provides a number of "quickie" functions for practical use and demonstration.

Some examples use Tiled maps. While this is one of the easiest way to make and import tile maps, it is not required. Any map source can be used as long as its data can be converted to the Map class's meager requirements. See the toolkit module for a few functions that load maps, and the Map class for documentation.

Note that if you want to use pymunk via the Engine class, you need to turn it on with use_pymunk=True. This explicitly tells the Engine constructor whether to use pymunk when initializing library objects. This avoids any problems that might arise if pymunk is installed but the game does not want to use pymunk objects. This is only of special note for the Engine constructor. The library doesn't assume anything. If pymunk can be imported, the package is available and pymunk subclasses are created in the model module; your game code can choose to use them, or ignore them. The library only uses them if you specify {{{Engine(use_pymunk=True)}}}. This is a very small amount of code; it should be pretty clear in `engine.Engine.__init__` and the model module.

The pymunk physics scale is intended to be based on pixels, however all attempts will be made to support sub-pixel math with floating point numbers. Sub-pixel math is compatible with the underlying physics engine, pymunk (chipmunk), and allows fractional speeds, mass, dimensions, etc. The display code must round and convert physics values to integers for pygame where appropriate.

Also, a general caution. Many underlying coordinate "points" are implemented as {{{Vec2d}}}. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when subclassing or choosing to directly access the underlying {{{obj._attributes}}}.

==Current focus==

Getting organized. Shuffling modules and classes around.

Developing a map editor, which seconds as a practical test of the library and the requirements driver for library features.

Anything marked DONE in the to-do list is not necessarily frozen. It is just considered adequately usable for the purpose it is most recently needed. These will certainly evolve as needed.

Features:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * Procedural object makers, e.g. random groups of baddies
  * Menu (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * Toolkit: hud and tile generators; map loader; render routines; map optimizer (DONE)
  * pymunk editing primitives
    * Line
    * Circle
    * Poly
    * Select
    * Multi-select
    * Move
    * Resize
    * Delete
    * Undo/Redo
  * ~~Map decorating and tiling~~
    * ~~Tileset loading~~
    * ~~Palette picking~~
    * ~~Screen picking~~
    * ~~Paint~~
    * ~~Erase~~
    * ~~Undo/redo~~
    * ~~Region selection~~
    * ~~Fill~~

==Working Notes==

===pymunk===

pymunk is barely more than a concept thus far. It is fundamentally proven in examples/08_pymunk_motion.py. The pygame portion of the library is about ready for use in map_editor.py.

===Map Editor===

The plan is for game makers to be able to load a map in the editor, draw pymunk shapes on them to define obstacles, then save a "physics map". Games will then be able to load the graphics map and physics map, and rely on pymunk for run-time physics.

I am liking the combination of Tiled Map Editor and pytmxloader. Initially map_editor.py will simply load the tile map, and let one add pymunk objects.

Since the Map class is already source agnostic, it may be easy enough to support multiple map editor formats just by adding another toolkit.load_`*` function.

The (Tiled) map layers feature can be used to classify terrain objects, for example "trees go on layer 5". Game makers (i.e. me) may want to do special things with these, like let mobile objects pass under or behind them and temporarily lower the image alpha so the mobile object is not entirely obscured. (This aspect weakens the case for map decorating and tiling in map_editor.py.)

_Maybe_ later the map editor can be extended to handle placement of dynamic game objects, for example, groups of orcs, gates, siege weapons. It would be nice to be able to insert the physical "device" into the map, and provide a handle for map loaders to detect "Ah, here is a Mark IV Gizmo. I'll load the graphics and game mechanics for it". This would be highly preferable to eyeballing map coordinates in the editor and hand entering code or data sets to place the many gizmos.