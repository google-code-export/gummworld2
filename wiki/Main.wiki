#summary Miscellaneous project notes.

= Introduction =

This is Gummworld2. It's designed as a light pygame framework for a scrolling game, where the map is larger than the display. It emphasizes simplicity, openness, and performance.

One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 solves this with a clean and simple update-and-draw run loop.

One should also be free to choose one's own audiovisual presentation, intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want; you are not forced to learn "The Gummworld Way", and wade through bloated features. Gummworld2 does this by providing just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use Tiled for maps and pymunk for physics, as it is quite easy to substitute your own.

One should not have to worry about juggling game speed and frame rates. Gummworld2's clock maintains steady game time and variable frame rate without the headaches.

One may wonder about the original Gummworld. While it was a great learning experience, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= Details =

The map editor performs basic scrolling of tiles by syncing a camera with a target object that moves about the map. Change the target object's position and the camera follows.

These are the key classes.

  State: A storage container for run-time objects, settings, and values. Because it's easy to access globally, this minimizes the need to pass around key objects in arguments. States can also be saved and restored by name, if desired. The mechanism is straightforward, thus easy to use and extend.

  Engine: A superclass providing the framework for initialization, run loop, update and draw methods, and pygame event handlers. If you decide to write your own engine, look in here to see how the key objects are created. Don't be afraid, no voodoo in here.

  Screen: Just yer basic display interface.

  Camera: Follows a target object around the map. Calculates 2D range of visible tiles. Constructs map layer lists of visible tiles. Converts 2D coordinates between world and screen space. Supports warping and interpolated scrolling.

  Map: Serves map tiles in layers. Also serves labels and grid lines.

  World: The underlying physics, based on pymunk. The Engine class uses this to maintain physical bodies for motion and collision. If you do not decide to use pymunk you can ignore this object. If you do not have pymunk installed, the World class will automatically live without it.

  GameClock: Keeps constant game time. Supports variable frame rate. Calculates interpolated fraction of a game tick, which can be used for prediction and sub-pixel motion.

There are a few utilities--a HUD, tile grid lines, tile labels, popup menu, toolkit (map generators, tile renders), pygame utilities module--to ease experimentation with concepts, but they are entirely optional. One can use Gummworld2 and easily ignore them.

The pymunk physics scale is intended to be based on pixels, however all attempts will be made to support sub-pixel math with floating point numbers. Sub-pixel math is compatible with the underlying physics engine, pymunk (chipmunk), and allows fractional speeds, mass, dimensions, etc. The display code must round and convert physics values to integers for pygame where appropriate.

Also, a general caution. Many underlying coordinate "points" are implemented as {{{Vec2d}}}. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when subclassing or choosing to directly access the underlying {{{obj._attributes}}}.

==Current focus==

Getting organized. Shuffling modules and classes around.

Developing a map editor, which seconds as a practical test of the library and the requirements driver for library features.

Anything marked DONE in the to-do list is not necessarily frozen. It is just considered adequately usable for the purpose it is most recently needed. They will certainly evolve as needed.

Features:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * Procedural object makers, e.g. random groups of baddies
  * Menu (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * pymunk editing primitives
    * Line
    * Circle
    * Poly
    * Select
    * Multi-select
    * Move
    * Resize
    * Delete
    * Undo/Redo
  * ~~Map decorating and tiling
    * ~~Tileset loading
    * ~~Palette picking
    * ~~Screen picking
    * ~~Paint
    * ~~Erase
    * ~~Undo/redo
    * ~~Region selection
    * ~~Fill

==Working Notes==

===Map Editor===

I am liking Tiled Map Editor and pytmxloader. It is looking like map_editor.py will simply load the tile map, and (initially) just let one add pymunk objects.

Since the Map class is already source agnostic, it may be easy enough to support multiple map editor formats just by adding another toolkit.load_`*` function.

The (Tiled) map layers feature can be used to classify terrain objects, for example "trees go on layer 5". Game makers (i.e. me) may want to do special things with these, like let mobile objects pass under or behind them and temporarily lower the image alpha so the mobile object is not entirely obscured. (Note that this aspect weakens the case for map decorating and tiling in map_editor.py.)