#summary Design and implementation progress.
#labels Featured

= Introduction =

This is Gummworld2. It's designed as a light [http://www.pygame.org pygame] framework for a scrolling game, where the map is larger than the display. It emphasizes simplicity, freedom, and performance.

One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 solves this with a few core classes and their structural requirements, and a clean and simple update-and-draw run loop.

One should also be free to choose one's own audiovisual presentation, game intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want. You are not forced to learn "The Gummworld Way", and wade through bloated features. Gummworld2 provides just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use the engine for the game framework, [http://www.mapeditor.org/ Tiled] for maps, and [http://www.pygame.org/project-pymunk-780-2576.html pymunk] for physics. If you prefer to use other libraries and utilities, it is quite easy to use Gummworld2 for scrolling maps and leverage your own tools.

One should not have to worry about juggling game speed and frame rates. Gummworld2's clock maintains steady game time and variable frame rate without the headaches, and the management classes do what they do with efficiency leaving more computer resources for game content.

Since this is Gummworld2, one may wonder about the original [http://www.pygame.org/project-Gummworld-1107-.html Gummworld]. While it was a great learning experience and a lot of fun, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= Details =

Gummworld2 is currently developed with Windows 7, Python 2.6, pygame 1.9.1, pymunk 1.0.0, and Tiled Map Editor 0.7.2 (the Java version). Most of the testing is on the development platform. Light testing for demo performance and operation has been done with Windows XP SP 2 and Ubuntu 10. Almost assuredly Gummworld2 will not work with pygame 1.8.1 and earlier, since various classes may not have provided the copy() method (most notably Rect).

The library performs basic scrolling of tiles by syncing a camera with a target object that moves about the large map space. Change the target object's position and the camera follows.

These are the core classes.

  State: A storage container for run-time objects, settings, and values. Because it's easy to access globally, this minimizes the need to pass around core objects in arguments. States can also be saved and restored by name, if desired. The mechanism is straightforward, thus easy to use and extend.

  Engine: A superclass providing the framework for initialization, run loop, update and draw methods, and pygame event handlers. If you decide to write your own engine, look in here to see how the core objects are created. Don't be afraid, no voodoo in here.

  Screen and Surface: Basic display and subsurface wrappers.

  Camera: Follows a target object around the map. Calculates 2D range of visible tiles. Constructs map-layer lists of visible tiles. Converts 2D coordinates between world and screen space. Provides interpolated scrolling, taking advantage of faster frame rates to smooth scrolling.

  Map: Serves map tiles in layers. Also serves labels and grid lines.

  World`*`: Containers for objects that define the game model. Choices are NoWorld, World, WorldQuadTree, and WorldPymunk which provide some "canned" options for implementing a world. You are free to use these, build your own, or ignore it entirely.

  GameClock: Keeps constant game time. Supports variable frame rate. Calculates interpolated fraction of a game tick, which can be used for prediction, sub-pixel motion, and precision timing.

  BucketSprite and BucketGroup: pygame-like classes that manage sprites in buckets for optimized updating and rendering. BucketGroup also has a tweaked draw() method needed to render sprites whose rects are expressed in world coordinates; versus pygame's which expect sprite rects to be expressed in screen coordinates. These are for game makers who prefer to use the sprite for both view and model.

The data module provides resource loaders for various data in the data subdirectories, a la skellington. It should be very easy to figure out and customize as needed.

The geometry module provides numerous collision routines to augment pygame's, geometric calculations, and some shapes.

There are a few utilities to simplify laborious tasks and ease experimentation with concepts: a HUD, map grid, tile labels, popup menu, map generators, Tiled map loader, tile renders, tile collapsing, pygame utilities module. The examples and map_editor.py rely upon those modules. However, they are not required by the library, with the exception that toolkit.py and pygame_utils.py. One can certainly use Gummworld2 for map scrolling and easily ignore the extras. Of special interest, the toolkit module provides a number of "quickie" functions for both practical use and demonstrations of how to manipulate library objects, most notably Map and Camera.

Some examples use Tiled maps. While this is one of the easiest ways to make and import tile maps, it is not required. Any map source can be used as long as its data can be converted to the Map class's meager requirements. See the toolkit module for a few functions that load maps, the bunny game for an ASCII map, and the Map class documentation.

Note that although pymunk and Tiled are supported, they are not required. There is no need to consider them if you prefer not to use them.

Lastly, a general caution. The instance variables representing 2D coordinates are typically implemented as `Vec2d`. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when overriding in subclasses or choosing to directly access the underlying private `_attributes`.

==Status Summary==

Initial efforts focused on the map, its visual presentation, and interface. Recently attention is wandering more towards the model. Thus, the API is still seeing a few changes, some of which break existing code. This was to be expected. Nevertheless, apologies for any inconvenience.

A mini game was finished in 0.0.2 as a proof-of-concept, and kept functional as the library evolved. The game and all but one example do not use an external physics library; I would describe them as pygame-only. A few examples use a Tiled map.

The editor concept has changed. It will not do map editing. Tiled already does that well. Gummworld2's editor will supplement Tiled's static maps by visually overlaying tagged geometry for physics--e.g. rects and circles for pygame; lines, circles, and polys for pymunk or others--and placement of interactive game content like baddies, doors, traps, anything you can think of. The geometry would typically be invisible in the game, and used for game events like:

  * Did these two space ships collide.
  * Did my truck venture into this sand pit.
  * Did the mouse click on this unit of soldiers.
  * Is this baddy in striking range of the avatar.
  * Is this defense tower visible in the camera view.

Performance is extremely good on my Intel Core i3 laptop. Not so great on my older AMD Athlon X2 desktop, but still much better than the original Gummworld; it screams at Diablo-like resolution (800x600), presumably leaving plenty of capacity for dynamic content. The proof-of-concept bunny game seems to support this expectation, with a two-layer 2056x2056-pixel map, 400 autonomous sprites, collision handling, and a split screen rendering at nearly 250 FPS on the Intel Core i3.

===Features===

Anything marked DONE in the following list is not necessarily frozen. It is just considered adequately usable for recent SVN revisions. These will certainly evolve as needed.

Library:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * World:
    * NoWorld is the default, for game makers that do not want a canned model (DONE)
    * World is a dumb model with a list for entities (DONE)
    * WorldQuadTree is an advanced model that provides optimal collision checking in large maps with many elements (DONE)
    * WorldPymunk is a model that leverages pymunk (bare bones)
  * Procedural object makers, e.g. random groups of baddies
  * Menu (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * Geometry for more collision detection choices without external library requirements (DONE)
  * Toolkit: hud and tile generators; map loader; render routines; map optimizer (DONE)

Editor:
  * pymunk editing primitives
    * Line
    * Circle
    * Poly
    * Select
    * Multi-select
    * Move
    * Resize
    * Delete
    * Undo/Redo
  * ~~Map decorating and tiling~~
    * ~~Tileset loading~~
    * ~~Palette picking~~
    * ~~Screen picking~~
    * ~~Paint~~
    * ~~Erase~~
    * ~~Undo/redo~~
    * ~~Region selection~~
    * ~~Fill~~

==Working Notes==

===Library===

===pymunk===

pymunk is barely more than a concept thus far. It is fundamentally proven in examples/08_pymunk_motion.py. The pygame portion of the library is about ready for use in map_editor.py.

===Map Editor===

(Temporarily on hold as the proof-of-concept bunny game is driving redefinition of the pygame library.)

The plan is for game makers to be able to load a map in the editor, draw pymunk shapes on it to define obstacles, then save a "physics map". Games will then be able to load the graphics map and physics map, and rely on pymunk or other implementations for run-time physics.

I am liking the combination of [http://www.mapeditor.org/ Tiled Map Editor] and [http://www.pygame.org/project-map+loader+for+%27tiled%27-1158-2951.html pytmxloader]. Initially the map editor will simply load the tile map, and let one add pygame or pymunk geometry.

Since the Map class is already source agnostic, it may be easy enough to support multiple map editor formats just by adding a `toolkit.load_*` function.

Map layers--Tiled or other--can be used to classify terrain objects, for example "trees go on layer 5". Game makers (i.e., me) may want to do special things with these, like let mobile objects pass under or behind them and temporarily lower the image alpha so the mobile object is not entirely obscured. (This aspect weakens the case for map decorating and tiling in map_editor.py.)

The map editor must also handle placement of dynamic game objects, for example, groups of orcs, gates, siege weapons. It is undecided yet if this will include loading tilesets for visual cues or content design; but it's essential to at least be able to insert a physical "device" into the map, and provide a handle and some data for a few reasons:

  # Shapes are needed for dimensions; and potentially more, in the case of pymunk.
  # Obviously, if objects in the physics dimension are interacting those interactions need to correlate with the display, or whatever is representing the colliding objects to the player.
  # Map loaders can detect "Ah, here is a Mark IV Gizmo. I'll load the graphics and game intelligence for it". Or the related non-physics game elements can spring into life as their physics are activated by game progression.
  # Using a map editor for placement would be highly preferable to eyeballing map coordinates in the map editor and hand entering code or data sets to place many gizmos on a map.