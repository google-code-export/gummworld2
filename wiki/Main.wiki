#summary Design and implementation overview.
#labels Featured
As of version 0.0.11 the world editor has reached a point where it was usable. Naturally, taking it out for its first real spin had surfaced many issues, all of which have been fixed in 0.0.12.

There have been quite a few changes to the library to fix issues, and support development of the world editor and its proof-of-concept demo, number 17. But no API changes have occurred since version 0.0.7.

= Introduction =

This is Gummworld2. It's designed as a light [http://www.pygame.org pygame] framework for a scrolling game, where the map is larger than the display. It emphasizes simplicity, freedom, and performance.

Gummworld2 is foremost about optimal scrolling. It provides just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use the engine for the game framework, [http://www.mapeditor.org/ Tiled] for maps, and [http://www.pygame.org/project-pymunk-780-2576.html pymunk] for physics. Examples are included to demonstrate the ease of incorporating these. If you prefer to use other libraries and utilities, it is quite easy to use Gummworld2 simply for scrolling maps and leverage your own tools.

Besides ease and speed of scrolling maps, Gummworld2 strives to maintain these ideals:

  One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 fosters this notion by requiring only a few core classes, and a clean and simple update-and-draw run loop.

  One should be free to choose one's own audiovisual presentation, game intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want. You are not forced to learn "The Gummworld Way", and wade through bloated features.

  One should not have to worry about juggling game speed and frame rates, and eking enough horsepower for a smooth gaming experience. Gummworld2's clock maintains steady game time and variable frame rate without the headaches, and the management classes and toolkit do what they do with efficiency leaving more computer resources for game content.

Given the name Gummworld2, one may wonder about the original [http://www.pygame.org/project-Gummworld-1107-.html Gummworld]. While it was a great learning experience and a lot of fun, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= API Overview =

Gummworld2 is currently developed with Windows 7, Python 2.6, pygame 1.9.1, pymunk 1.0.0, and Tiled Map Editor 0.7.2 (the Java version). Most of the testing is on the development platform. Light testing for demo performance and operation has been done with Windows XP SP 2 and Ubuntu 10. Almost assuredly Gummworld2 will not work with pygame 1.8.1 and earlier, since various classes may not have provided the copy() method (most notably Rect) and other new features.

The library performs basic scrolling of tiles by syncing a camera with a target object that moves about the large map space. Change the target object's position and the camera follows.

These are the core classes.

  State: A storage container for run-time objects, settings, and values. Because it's easy to access globally, this minimizes the need to pass around core objects in arguments. States can also be saved and restored by name, if desired. The mechanism is straightforward, thus easy to use and extend.

  Engine: A superclass providing the framework for initialization, run loop, update and draw methods, and pygame event handlers. If you decide to write your own framework, look in here to see how the core objects are created. Don't be afraid, no voodoo in here.

  Screen and View: Basic display and subsurface wrappers.

  Camera: Follows a target object around the map. Calculates 2D range of visible tiles. Constructs map-layer lists of visible tiles. Converts 2D coordinates between world and screen space. Provides interpolated scrolling, taking advantage of faster frame rates to smooth the scrolling experience.

  Map: Serves map tiles in layers. Also serves labels and grid lines as design aids.

  World`*`: Containers for objects that define the game model. Choices are NoWorld, World, WorldQuadTree, and WorldPymunk which provide some "canned" options for implementing a world. You are free to use these, build your own, or ignore it entirely.

  GameClock: Keeps constant game time. No-fuss variable frame rate. Calculates interpolated fraction of a game tick, which can be used for prediction, sub-pixel motion, and precision timing.

  BucketSprite and BucketGroup: pygame-like classes that manage sprites in buckets for optimized updating and rendering. BucketGroup also has a tweaked draw() method needed to render sprites whose rects are expressed in world coordinates; versus pygame's which expect sprite rects to be expressed in screen coordinates. These are for game makers who prefer to use the sprite for both view and model.

The data module provides resource loaders for various data in the data subdirectories, a la skellington. It should be very easy to figure out and customize as needed.

The geometry module provides numerous collision routines to augment pygame's, geometric calculations, and some shapes.

There are a few utilities to simplify laborious tasks and ease experimentation with concepts: a HUD, map grid, tile labels, popup menu, map generators, Tiled map loader, tile renders, tile collapsing, pygame utilities module. The examples and map_editor.py rely upon those modules. However, they are not required by the library, with the exception that toolkit.py and pygame_utils.py. One can certainly use Gummworld2 for map scrolling and easily ignore the extras. Of special interest, the toolkit module provides a number of "quickie" functions for both practical use and demonstrations of how to manipulate library objects, most notably Map and Camera.

Some examples use Tiled maps. While this is one of the easiest ways to make and import tile maps, it is not required. Any map source can be used as long as its data can be converted to the Map class's meager requirements. See the toolkit module for a few functions that load maps, the bunny game for an ASCII map, and the Map class documentation.

Note that although pymunk and Tiled are supported, they are not required. There is no need to consider them if you prefer not to use them.

Lastly, a general caution. The instance variables representing 2D coordinates are typically implemented as `Vec2d`. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when overriding in subclasses or choosing to directly access the underlying private `_attributes`.

==Status Summary==

Initial efforts focused on the map, its visual presentation, and interface. Recently attention has turned to the world (model) editor. The API has not had any code-breaking changes since version 0.0.7.

A mini game was finished in 0.0.2 as a proof-of-concept, and kept functional as the library evolved. The game and all but one example do not use an external physics library; I would describe them as pygame-only. A few examples use a Tiled map.

The editor concept has narrowed. It will not do map editing. Tiled already does that well. Gummworld2's editor will supplement Tiled's static maps by visually overlaying tagged geometry for physics--e.g. rects and circles for pygame; lines, circles, and polys for pymunk or others--and placement of interactive game content like baddies, doors, traps, anything you can think of. The geometry would typically be invisible in the game, and used for game events like:

  * Did these two space ships collide.
  * Did my truck venture into this sand pit.
  * Did the mouse click on this unit of soldiers.
  * Is this baddy in striking range of the avatar.
  * Is this defense tower visible in the camera view.

Performance is extremely good on my Intel Core i3 laptop. Not so great on my older AMD Athlon X2 desktop, but still much better than the original Gummworld; it screams at Diablo-like resolution (800x600), presumably leaving plenty of capacity for dynamic content. The proof-of-concept bunny game seems to support this expectation, with a two-layer 2056x2056-pixel map, 400 autonomous sprites, collision handling, and a split screen rendering at nearly 250 FPS on the Intel Core i3.

An aged Intel single-core 1.8 GHz with cheap on-board video and SDRAM pulled off 40-60 FPS on examples. However, the scrolling experience was sluggish and really jerky since the platform was not fast enough to drive smooth interpolation and still work in garbage collection. The quadtree examples did not run acceptibly at all, except with low sprite counts.

===Features===

Anything marked DONE in the following list is not necessarily frozen. It is just considered adequately usable for recent SVN revisions. These will certainly evolve as needed.

Library:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * World:
    * NoWorld is the default, for game makers that do not want a canned model (DONE)
    * World is a dumb model with a list for entities (DONE)
    * WorldQuadTree is an advanced model that provides optimal collision checking in large maps with many elements (DONE)
    * WorldPymunk is a model that leverages pymunk; needs more shape classes and pymunk-ish things (incomplete)
  * Procedural object makers, e.g. random groups of baddies
  * Menu (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * Geometry for more collision detection choices without external library requirements (DONE)
  * Toolkit: hud and tile generators; map loader; render routines; map optimizer (DONE)

Editor:
  * pymunk editing primitives
    * Line
    * Rect (DONE)
    * Circle (DONE)
    * Poly (DONE)
    * Select (DONE)
    * Multi-select
    * Move (DONE)
    * Resize (DONE)
    * Delete (DONE)
    * Undo/Redo
  * ~~Map decorating and tiling~~
    * ~~Tileset loading~~
    * ~~Palette picking~~
    * ~~Screen picking~~
    * ~~Paint~~
    * ~~Erase~~
    * ~~Undo/redo~~
    * ~~Region selection~~
    * ~~Fill~~

==Working Notes==

===Library===

===pymunk===

pymunk is barely more than a concept thus far. It is fundamentally proven in examples/08_pymunk_motion.py. The pygame portion of the library is about ready for use in map_editor.py. There will be a world-editor file importer for pymunk.

===World Editor===

The plan is for game makers to be able to load a map in the editor, draw shapes on it to define game objects, then save a "physics map". Games will then be able to load the graphics map and physics map, and rely on pymunk or other implementations for run-time physics.

I am liking the combination of [http://www.mapeditor.org/ Tiled Map Editor] and [http://www.pygame.org/project-map+loader+for+%27tiled%27-1158-2951.html pytmxloader]. Initially the world editor will simply load the tile map, and let one add geometry and tag it with arbitrary info. The exported file will contain all the info needed to recreate shapes in game, and get their info tags.

Since the Map class is already source agnostic, it may be easy enough to support multiple map editor formats just by adding a `toolkit.load_*` function or perhaps extension scripts.

Thought... Map layers--Tiled or other--can be used to classify terrain objects, for example "trees go on layer 5". Game makers (i.e., me) may want to do special things with these, like let mobile objects pass under or behind them and temporarily lower the image alpha so the mobile object is not entirely obscured. (This aspect weakens the case for map decorating and tiling in map_editor.py.)

Drawing boundaries on a static map is admittedly nice. However, the world editor must also handle placement of "spawned" game objects, i.e. objects that are not in static map layers. For example, groups of orcs, gates, siege weapons, random rubble. The world editor will likely have to load tilesets to aid visualizing world content design. It's essential to at least be able to insert a physical "device" into the world map, size its geometry accurately, and provide a handle or descriptive data for a few reasons:

  # Shapes are needed for dimensions; and potentially other physics-related purposes in the case of pymunk.
  # Obviously, if objects in the physics dimension are interacting those interactions need to correlate with the presentation layer.
  # Map loaders could detect "Ah, here is a Mark IV Gizmo. I'll load the graphics and game intelligence for it". Or run-time game logic can load presentation content on the fly when the physics are activated by game progression.
  # Using a world editor for placement would be highly preferable to eyeballing map coordinates in the world editor and hand entering code or data sets to place many gizmos on a map.