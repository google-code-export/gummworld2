#summary Design and implementation overview.
#labels Featured

= News =

The newest pymunk's API changes make it incompatible with Gummworld2. Consequently, the decision is made to deprecate the pymunk aspects of Gummworld2 (i.e. the automatic import, the references in modules engine, model, and anywhere else). This decision was made after it became clear that pymunk was not as valuable to my projects as originally expected. It is still easy enough to incorporate pymunk into Gummworld2 by stepping it the Engine.update() method. This is what I have been doing myself instead of using any of the canned "world" classes, which frankly are still undeveloped.

So here's the word: choose your own model or physics, or design your own. On the one hand, you'll have to do this on your own steam. On the other hand: 1) You have to freedom (just as you always had with Gummworld2) to select or design the model that works best for you; 2) You won't have to struggle with learning someone else's (my) idea of a monstrous, inefficient model that tries to fulfill every need and misses the mark; 3) In my opinion, it is the most fun part of programming!

==v0.4.2==

Version 0.4.2 adds some improvements. Most notably a BasicMapRenderer class as an optional replacement for collapsing tiles, which resolves the hassle and memory waste issues with the collapse implementation while providing the same high-performance scrolling.

There is also the new LineGeometry, which had been too long neglected. A change to SpatialHash accompanies the new geometry, so that collisions between lines and all shapes can be detected.

There is a significant a bug. BasicMapRenderer.set_dirty() blows up. This has been fixed in revision 402, and an example has been added. Please pull from the repo if you really need this fix. It is only one file.

There is a minor bug. gummworld2/version.py still says 0.4.1. Sorry for any inconvenience.

==gw2 Skeleton==

The skeleton provides a skellington-like directory structure into which a gummworld2 distro can be dropped to quick-start a project. The skeleton provides launchers for three purposes: debugging output launcher, normal command-line launcher, and Windows Python launcher. It also provides stub context modules for a game's settings, main, intro, menu, game, and credits. The stubs function right out of the box, but require custom content to do anything useful beyond a "put message here" splash screen and uninteresting game menu. This supports quick prototyping and project startup which can save hours of repetitive work.

==v0.3.0==

With release v0.3.0 the tiled2 branch is live. The included tiletmxloader v3 brings optimizations and bug fixes. The gummworld2 library brings many optimizations and a few bug fixes, and quite a bit of internal redesign as well as some API changes. Some dead modules and toolkit functions have been removed.

SpatialHash replaces Quadtree and 2D arrays for map objects storage. It is much more flexible and easy to query than arrays, and a lot faster than Quadtree.

A new SuperMap class joins an arbitrary number of maps together, with memory-friendly auto-loading and unloading and other features. This class is also super easy to use, and enables unlimited world building.

API changes were necessary to bring in the new features.

= Introduction =

This is Gummworld2. It's designed as a light [http://www.pygame.org pygame] framework for a [http://pyweek.org/e/multifac/ scrolling game], where the map is larger than the display. It emphasizes simplicity, freedom, and performance.

Gummworld2 is foremost about optimal scrolling. It provides just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use the engine for the game framework, and [http://www.mapeditor.org/ Tiled] for maps. Examples and a toolkit are included to demonstrate the ease of incorporating these. If you prefer to use other libraries and utilities, it is quite easy to use Gummworld2 simply for scrolling maps and leverage your own tools.

In fact, even maps and scrolling are optional. If you wish to use the Engine or core classes simply for the program framework, Gummworld2 [http://pyggy.pyweek.org/e/gummX1/ lends itself well].

Besides ease and speed of scrolling maps, Gummworld2 strives to maintain these ideals:

  One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 fosters this notion by requiring only a few core classes, and a clean and simple update-and-draw run loop.

  One should be free to choose one's own audiovisual presentation, game intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want. You are not forced to learn "The Gummworld Way", and wade through bloated features.

  One should not have to worry about juggling game speed and frame rates, and eking enough horsepower for a smooth gaming experience. Gummworld2's clock maintains steady game time and variable frame rate without the headaches. The management classes and toolkit do what they do with efficiency leaving more computer resources for game content.

Given the name Gummworld2, one may wonder about the original [http://www.pygame.org/project-Gummworld-1107-.html Gummworld]. While it was a great learning experience and a lot of fun, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= API Overview =

Gummworld2 is currently developed with Windows 7, Python 2.6, pygame 1.9.1, and Tiled Map Editor 0.6.1 (the Qt version). Most of the testing is on the development platform. Light testing for demo performance and operation has been done with Windows XP SP 2 and Ubuntu 10. Almost assuredly Gummworld2 will not work with pygame 1.8.1 and earlier, since various classes may not have provided the copy() method (most notably Rect) and other new features.

The library performs basic scrolling of tiles by syncing a camera with a target object that moves about the large map space. Change the target object's position and the camera follows.

These are the core classes.

  State: A storage container for run-time objects, settings, and values. Because it's easy to access globally, this minimizes the need to pass around core objects in arguments. States can also be saved and restored by name, if desired. The mechanism is straightforward, thus easy to use and extend.

  Engine: A superclass providing the framework for initialization, run loop, update and draw methods, and pygame event handlers. If you decide to write your own framework, look in here to see how the core objects are created. Don't be afraid, no voodoo in here.

  Screen and View: Basic display and subsurface wrappers.

  Camera: Follows a target object around the map. Calculates 2D range of visible tiles. Constructs map-layer lists of visible tiles. Converts 2D coordinates between world and screen space. Provides interpolated scrolling, taking advantage of faster frame rates and time-sensitive positioning to smooth the scrolling experience.

  Map: Serves map tiles in layers. Also serves labels and grid lines as design aids.

~~  World`*`: Containers for objects that define the game model. Choices are NoWorld, World, WorldQuadTree, and WorldPymunk which provide some "canned" options for implementing a world. You are free to use these, build your own, or ignore it entirely. ~~ World, aka model, is targeted for removal. There are many designs for model, and it seems unwise to impose a single front-end. It is best to leave it up to the individual. Engine.update() is the stub intended to step the model.

  GameClock: Keeps constant game time. No-fuss variable frame rate. Calculates interpolated fraction of a game tick, which can be used for prediction, sub-pixel motion, and precision timing.

BucketSprite and BucketGroup: Not core classes, but worthy of mention. They are pygame-like classes that manage sprites in buckets for optimized updating and rendering. BucketGroup also has a tweaked draw() method needed to render sprites whose rects are expressed in world coordinates--versus pygame's which expect sprite rects to be expressed in screen coordinates. These are for game makers who prefer to use the sprite for both view and model.

The data module provides resource loaders for various data in the data subdirectories, a la skellington. It should be very easy to figure out and customize as needed.

The geometry module provides numerous collision routines to augment pygame's, geometric calculations, and some shapes.

There are a few utilities to simplify laborious tasks and ease experimentation with concepts: a HUD, map grid, tile labels, popup menu, map generators, Tiled map loader, tile renders, tile collapsing, pygame utilities module, and PGU's gui package. The examples and world_editor.py rely upon those modules. However, they are not required by the library, with the exception that toolkit.py and pygame_utils.py. Of special interest, the toolkit module provides a number of "quickie" functions for both practical use and demonstrations of how to manipulate library objects, most notably Map and Camera.

The nicer examples use Tiled maps. While this is one of the easiest ways to make and import tile maps, it is not required. Any map source can be used as long as its data can be converted to the Map class's meager requirements. See the toolkit module for a few functions that load maps, the bunny game for an ASCII map, and the Map class documentation.

Note that although Tiled is supported, it is not required. There is no need to consider it if you prefer not to use it. However, at this time the world editor only imports Tiled maps. Tiled maps are not critical to the operation of the editor or Gummworld2, but at present they certainly make designing layout a lot easier in the editor.

Lastly, a general caution. The instance variables representing 2D coordinates are typically implemented as `Vec2d`. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when overriding in subclasses or choosing to directly access the underlying private `_attributes`.

==Status Summary==

Initial efforts focused on the map, its visual presentation, and interface. Recently attention has turned to the world (model) editor. The API has not had any code-breaking changes since version 0.0.7.

A mini game was finished in 0.0.2 as a proof-of-concept, and kept functional as the library evolved. The game and all but one example do not use an external physics library; I would describe them as pygame-only. A few examples use Tiled maps.

The editor is not a map editor. Tiled already does that well. Gummworld2's editor supplements Tiled's static maps by visually overlaying tagged geometry for physics--e.g. lines, rects, circles, and polygons--and placement of interactive game content, e.g. baddies, doors, traps. The geometry would typically be invisible in the game, and used for game events like:

  * Did my space ship hit the cavern wall.
  * Did my truck venture into this sand pit.
  * Did the mouse click on this unit of soldiers.
  * Is this baddy in striking range of the avatar.
  * Is this defense tower visible in the camera view.

Performance is extremely good on my Intel Core i3 laptop. Not so great on my older AMD Athlon X2 desktop, but still much better than the original Gummworld; demos scream at Diablo-like resolution (800x600), leaving plenty of capacity for dynamic content.

An aged Intel single-core 1.8 GHz with cheap on-board video and DDR-333 pulled off 40-60 FPS on examples. However, the scrolling experience was sluggish and really jerky since the platform was not fast enough to drive smooth interpolation and still work in garbage collection. The quadtree examples did not run acceptably at all, except with low sprite counts. Scrolling on old platforms such as this may still be possible at smaller resolutions.

===Features===

Anything marked DONE in the following list is not necessarily frozen. It is just considered adequately usable for recent SVN revisions. These will certainly evolve as needed.

Library:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * World:
    * NoWorld is the default, for game makers that do not want a canned model (DONE)
    * World is a dumb model with a list for entities (DONE)
    * WorldQuadTree is an advanced model that provides optimal collision checking in large maps with many elements (DONE)
  * Menu (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * Geometry for more collision detection choices without external library requirements (DONE)
  * Toolkit: hud and tile generators; map loader; world entity loader; render routines; map optimizers (DONE)

Editor:
  * Editing primitives
    * Line (still thinking; it's not compatible with QuadTree)
    * Rect (DONE)
    * Circle (DONE)
    * Polygons (DONE)
    * Select (DONE)
    * Multi-select
    * Move (DONE)
    * Resize (DONE)
    * Delete, cut, copy, paste (DONE)
    * Undo/Redo
  * Map decorating and tiling (for in-editor visual aid only)
    * Tileset loading (DONE)
    * Palette picking (DONE)
    * Screen picking (DONE)
    * Stamping (DONE)
    * Erasing (DONE)

==Working Notes==

===Library===

===World Editor===

Game makers can load a map in the editor, draw shapes on it to define game objects, then save a "physics map". Games can load the graphics and physics maps, and rely on custom or third-party implementations for run-time physics. For Python purists, Gummworld2 provides a high-performance SpatialHash implementation that is compatible with geometric shapes (lines, rects, polys, circles in the geometry module) for collision detection and culling.

[http://www.mapeditor.org/ Tiled Map Editor] and [http://www.pygame.org/project-map+loader+for+%27tiled%27-1158-2951.html pytmxloader] make a great team. It is a no-brainer to use them, unless you've got a pile of reusable content from other sources.

Placing static obstacles and boundaries on a map is admittedly nice. However, the world editor can also be used to place "spawned" game objects, i.e. objects that are not in static map layers. For example, groups of orcs, gates, siege weapons, random rubble. The world editor can load tilesets to aid visualizing world content design. It's very useful to be able to insert a physical "device" into the world map, size its geometry accurately, and provide a handle or descriptive data for a few reasons:

  # Shapes are needed for dimensions; and potentially other physics-related purposes.
  # Shapes do not necessarily require a visual component.
  # Shapes offer geometry options. One can choose irregular shapes, or shapes that snug the edges of visuals smaller than an entire tile.
  # Obviously, if objects in the physics dimension are interacting those interactions need to correlate with the presentation layer.
  # World loaders could detect "Ah, here is a Mark IV Gizmo. I'll load the graphics and game intelligence for it". Or run-time game logic can load presentation content on the fly when the physics are activated by game progression.