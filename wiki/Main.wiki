#summary Design and implementation progress.
#labels Featured

= Introduction =

This is Gummworld2. It's designed as a light pygame framework for a scrolling game, where the map is larger than the display. It emphasizes simplicity, freedom, and performance.

One should not have to struggle with making a game concept fit into a restrictive paradigm. Gummworld2 solves this with a clean and simple update-and-draw run loop.

One should also be free to choose one's own audiovisual presentation, game intelligence, and GUIs. The benefits should be obvious. Low learning curve: use what you know. Freedom: use whatever you want; you are not forced to learn "The Gummworld Way", and wade through bloated features. Gummworld2 provides just a few management classes, driven by a very simple (optional) engine. It is merely a _suggestion_ to use the engine for the game framework, Tiled for maps, and pymunk for physics. It is quite easy to substitute your own.

One should not have to worry about juggling game speed and frame rates. Gummworld2's clock maintains steady game time and variable frame rate without the headaches.

One may wonder about the original Gummworld. While it was a great learning experience and a lot of fun, it became obvious it was more ambitious than it should have been. It turned out overly complex and restrictive, with a higher learning curve than intended. Consequently it became hard to do anything outside the box.

= Details =

The library performs basic scrolling of tiles by syncing a camera with a target object that moves about the map. Change the target object's position and the camera follows.

These are the core classes.

  State: A storage container for run-time objects, settings, and values. Because it's easy to access globally, this minimizes the need to pass around core objects in arguments. States can also be saved and restored by name, if desired. The mechanism is straightforward, thus easy to use and extend.

  Engine: A superclass providing the framework for initialization, run loop, update and draw methods, and pygame event handlers. If you decide to write your own engine, look in here to see how the core objects are created. Don't be afraid, no voodoo in here. Note that if you want to use pymunk via the Engine, you need to turn it on with use_pymunk=True.

  Screen: Just yer basic display interface.

  Camera: Follows a target object around the map. Calculates 2D range of visible tiles. Constructs map layer lists of visible tiles. Converts 2D coordinates between world and screen space. Supports warping and interpolated scrolling.

  Map: Serves map tiles in layers. Also serves labels and grid lines.

  World: Container for objects that are subject to the game physics. If you decide to use pyymunk this is where space and bodies exist. If you decide not to use pymunk you can build your own physics into it, or ignore it entirely.

  GameClock: Keeps constant game time. Supports variable frame rate. Calculates interpolated fraction of a game tick, which can be used for prediction, sub-pixel motion, and precision timing.

The data module provides resource loaders for various data in the data subdirectories, a la skellington. It should be very easy to figure out and customize as needed.

There are a few utilities to simplify laborious tasks and ease experimentation with concepts: a HUD, map grid, tile labels, popup menu, map generators, Tiled map loader, tile renders, pygame utilities module. The examples and map_editor.py rely upon those modules. However, they are not required for games, with the exception that pygame_utils.py is required by the Engine class. One can certainly use Gummworld2 for map scrolling and easily ignore them. Of special interest, the toolkit module provides a number of "quickie" functions for both practical use and demonstration.

Some examples use Tiled maps. While this is one of the easiest ways to make and import tile maps, it is not required. Any map source can be used as long as its data can be converted to the Map class's meager requirements. See the toolkit module for a few functions that load maps, and the Map class documentation.

Note that if you want to use pymunk via the Engine class, you need to turn it on with use_pymunk=True. This explicitly tells the Engine constructor whether to use pymunk when initializing library objects. This avoids any problems that might arise if pymunk is installed but the game does not want to use the pymunk package. This is only of special note for the Engine constructor. The library doesn't assume anything. If pymunk can be imported, then it is available and pymunk subclasses are created in the `model` module; your game code can choose to use them, or ignore them. The engine only creates pymunk core objects if you specify `Engine(use_pymunk=True)`. This "if pymunk" logic is a very small amount of code in `engine.Engine.__init__` and the model module; it should be pretty clear.

The default pymunk physics scale is intended to be based on pixels (see `model.CircleBody`), however all attempts will be made to support sub-pixel math with floating point numbers. Sub-pixel math allows fractional speeds, mass, dimensions, etc. The display code must round and convert physics values to integers for pygame where appropriate.

Also, a general caution. The instance variables representing 2D coordinates are typically implemented as `Vec2d`. Attempts will be made to protect them from direct assignment, as clobbering them with a sequence or other object will break some library routines. Keep this in mind when subclassing or choosing to directly access the underlying `obj._attributes`.

==Current Status==

In the past few commits the API has seen less restructuring.

Developing a map editor, which seconds as a practical test of the library and the requirements driver for library features.

Performance is extremely good on my Intel Core i3 laptop. Not so great on my older AMD Athlon X2 desktop, but still much better than the original Gummworld; it screams at Diablo resolution (800x600), presumably leaving plenty of capacity for dynamic content.

===Features===

Anything marked DONE in the following list is not necessarily frozen. It is just considered adequately usable for recent SVN revisions. These will certainly evolve as needed.

Library:
  * Application framework, aka "engine" (DONE)
  * Camera: world-to-screen, screen-to-world, tile picking, interpolated scrolling (DONE)
  * Map: layered tile serving (DONE)
  * Procedural object makers, e.g. random groups of baddies
  * Menu (DONE)
  * Grid (DONE)
  * HUD (DONE)
  * Toolkit: hud and tile generators; map loader; render routines; map optimizer (DONE)

Editor:
  * pymunk editing primitives
    * Line
    * Circle
    * Poly
    * Select
    * Multi-select
    * Move
    * Resize
    * Delete
    * Undo/Redo
  * ~~Map decorating and tiling~~
    * ~~Tileset loading~~
    * ~~Palette picking~~
    * ~~Screen picking~~
    * ~~Paint~~
    * ~~Erase~~
    * ~~Undo/redo~~
    * ~~Region selection~~
    * ~~Fill~~

==Working Notes==

===pymunk===

pymunk is barely more than a concept thus far. It is fundamentally proven in examples/08_pymunk_motion.py. The pygame portion of the library is about ready for use in map_editor.py.

===Map Editor===

The plan is for game makers to be able to load a map in the editor, draw pymunk shapes on them to define obstacles, then save a "physics map". Games will then be able to load the graphics map and physics map, and rely on pymunk for run-time physics.

I am liking the combination of Tiled Map Editor and pytmxloader. Initially map_editor.py will simply load the tile map, and let one add pymunk objects.

Since the Map class is already source agnostic, it may be easy enough to support multiple map editor formats just by adding another toolkit.load_`*` function.

The (Tiled) map layers feature can be used to classify terrain objects, for example "trees go on layer 5". Game makers (i.e. me) may want to do special things with these, like let mobile objects pass under or behind them and temporarily lower the image alpha so the mobile object is not entirely obscured. (This aspect weakens the case for map decorating and tiling in map_editor.py.)

_Maybe_ later the map editor can be extended to handle placement of dynamic game objects, for example, groups of orcs, gates, siege weapons. It would be nice to be able to insert the physical "device" into the map, and provide a handle for map loaders to detect "Ah, here is a Mark IV Gizmo. I'll load the graphics and game mechanics for it". This would be highly preferable to eyeballing map coordinates in the editor and hand entering code or data sets to place the many gizmos.